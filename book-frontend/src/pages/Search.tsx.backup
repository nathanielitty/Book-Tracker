import React, { useState, useEffect } from 'react';
import { completeBookList, SampleBook } from '../data/sampleBooks';
import { Shelf } from '../types';

const Search: React.FC = () => {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<SampleBook[]>([]);
  const [shelfMap, setShelfMap] = useState<Record<string, Shelf>>({});
  const [message, setMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [selectedGenre, setSelectedGenre] = useState<string>('all');
  const [sortBy, setSortBy] = useState<string>('relevance');

  // Get all unique genres from the complete book list
  const getAllGenres = () => {
    const genreSet = new Set<string>();
    completeBookList.forEach(book => {
      book.genre.forEach(g => genreSet.add(g));
    });
    return Array.from(genreSet).sort();
  };

  const [allGenres] = useState(getAllGenres());

  useEffect(() => {
    // Show popular books initially
    const popularBooks = completeBookList
      .sort((a, b) => b.ratingsCount - a.ratingsCount)
      .slice(0, 12);
    setResults(popularBooks);
    const map: Record<string, Shelf> = {};
    popularBooks.forEach(b => { map[b.id] = Shelf.WANT_TO_READ; });
    setShelfMap(map);
  }, []);

  const doSearch = () => {
    if (!query.trim() && selectedGenre === 'all') {
      // Show popular books when no search criteria
      const popularBooks = completeBookList
        .sort((a, b) => b.ratingsCount - a.ratingsCount)
        .slice(0, 20);
      setResults(popularBooks);
      return;
    }
    
    setIsLoading(true);
    
    // Simulate API delay
    setTimeout(() => {
      let filteredBooks = completeBookList;

      // Filter by search query
      if (query.trim()) {
        const searchTerm = query.toLowerCase();
        filteredBooks = filteredBooks.filter(book =>
          book.title.toLowerCase().includes(searchTerm) ||
          book.author.toLowerCase().includes(searchTerm) ||
          book.description.toLowerCase().includes(searchTerm) ||
          book.genre.some(g => g.toLowerCase().includes(searchTerm))
        );
      }

      // Filter by genre
      if (selectedGenre !== 'all') {
        filteredBooks = filteredBooks.filter(book =>
          book.genre.includes(selectedGenre)
        );
      }

      // Sort results
      switch (sortBy) {
        case 'rating':
          filteredBooks.sort((a, b) => b.averageRating - a.averageRating);
          break;
        case 'popularity':
          filteredBooks.sort((a, b) => b.ratingsCount - a.ratingsCount);
          break;
        case 'newest':
          filteredBooks.sort((a, b) => b.publishedYear - a.publishedYear);
          break;
        case 'title':
          filteredBooks.sort((a, b) => a.title.localeCompare(b.title));
          break;
        default:
          // Keep current order for relevance
          break;
      }

      setResults(filteredBooks.slice(0, 50)); // Limit to 50 results
      
      // Default shelf selection
      const map: Record<string, Shelf> = {};
      filteredBooks.forEach(b => { map[b.id] = Shelf.WANT_TO_READ; });
      setShelfMap(map);
      setMessage('');
      setIsLoading(false);
    }, 500);
  };

  const addToShelf = (book: SampleBook) => {
    const shelfName = shelfMap[book.id].replace('_', ' ').toLowerCase();
    setMessage(`Added "${book.title}" to ${shelfName}`);
    // In a real app, this would make an API call
    setTimeout(() => setMessage(''), 3000);
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    doSearch();
  };

  const clearSearch = () => {
    setQuery('');
    setSelectedGenre('all');
    setSortBy('relevance');
    // Show popular books
    const popularBooks = completeBookList
      .sort((a, b) => b.ratingsCount - a.ratingsCount)
      .slice(0, 12);
    setResults(popularBooks);
  };

  return (
    <div className="page">
      <h2>Search Books</h2>
      <div className="search-bar">
        <form onSubmit={handleSubmit}>
          <input
            type="text"
            placeholder="Search books..."
            value={query}
            onChange={e => setQuery(e.target.value)}
          />
          <button type="submit" disabled={isLoading}>
            {isLoading ? 'Searching...' : 'Search'}
          </button>
        </form>
      </div>
      {message && <p className="message">{message}</p>}
      <div className="results">
        {results.map(book => (
          <div key={book.externalId} className="book-card">
            {book.thumbnailUrl && <img src={book.thumbnailUrl} alt={book.title} />}
            <div className="info">
              <h3>{book.title}</h3>
              <p className="authors">{book.authors?.join(', ')}</p>
              <p className="description">{book.description?.substring(0, 200)}{book.description?.length > 200 ? '...' : ''}</p>
              <div className="book-actions">
                <select
                  value={shelfMap[book.externalId] || Shelf.WANT_TO_READ}
                  onChange={e => setShelfMap(prev => ({ ...prev, [book.externalId]: e.target.value as Shelf }))}
                >
                  {Object.values(Shelf).map(s => (
                    <option key={s} value={s}>{s.replace('_', ' ')}</option>
                  ))}
                </select>
                <button onClick={() => addToShelf(book)}>Add</button>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default Search;